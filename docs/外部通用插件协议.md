 本协议旨在定义一套通用的 **JSON 交互标准**，使得 Python 执行平面能够通过“盲执行”**模式调用任意外部 HTTP 服务，实现**“新增工具无需修改代码”的设计目标。

****

### **一、 协议结构**
**这个 JSON 对象包含四个核心部分：**

1. Meta (元数据)： 用于描述工具的基本信息，决定 LLM 是否选择调用该工具。  

```json
{
  "name": "search_company_basic",  // 唯一标识，英文
  "description": "根据关键词查询企业工商信息..." // 给 LLM 看的 Prompt
}
```

2. Parameters (参数定义)： 给 LLM 看的（我需要什么参数），完全兼容 OpenAI Function Calling 格式。

```json
"parameters": {
  "type": "object",
  "properties": {
    "keyword": {
      "type": "string",
      "description": "企业名称关键词"
    },
    "page_index": {
      "type": "integer",
      "default": 1
    }
  },
  "required": ["keyword"] // 必填字段
}
```

3. Execution (执行逻辑)： 指导 HTTP Client （RUOYI）如何发起请求。  

```json
"execution": {
  "method": "GET", // HTTP 方法: GET | POST | PUT | DELETE
  "base_url": "http://api.qichacha.com/ECIV4/Search", // 接口地址
  "content_type": "application/x-www-form-urlencoded", // 请求体格式
  "param_placement": "query" // 参数位置映射: 'query' (URL参数) | 'body' (请求体) | 'path' (路径参数)
}
```

4. Auth Mapping (鉴权映射)：  定义如何将运行时的凭证（Credentials）动态注入到 HTTP 请求中。  

```json
"auth_config": {
  "type": "api_key", // 鉴权类型: api_key | bearer | basic | oauth2
  "mapping": [
    {
      "source": "QCC_KEY",       // 源：对应 Payload 中 credentials 的 Key 名称
      "target": "Token",         // 目标：HTTP Header 或 Query 参数的 Key 名称
      "location": "header"       // 位置: header | query
    }
  ]
}
```

### 二、 协议详情
以 **“企查查-企业关键词查询”** 为例，这是存储在 RuoYi 数据库中的完整定义：

```json
{
  "schema_version": "v1",
  
  // 1. Meta: 决定 LLM 是否调用此工具
  "name": "search_company_basic",
  "description": "根据关键词（如公司名、注册号）查询企业的基础工商信息（成立日期、法人、状态等）。当用户询问某家公司的基本情况时调用。",
  
  // 2. Parameters: 标准 JSON Schema，直接传给 LLM
  "parameters": {
    "type": "object",
    "properties": {
      "keyword": {
        "type": "string",
        "description": "企业名称关键词，例如'字节跳动'或'腾讯科技'"
      },
      "page_index": {
        "type": "integer",
        "description": "页码，默认为1",
        "default": 1
      }
    },
    "required": ["keyword"]
  },

  // 3. Execution: 告诉 Python 怎么发 HTTP 请求
  "execution": {
    "method": "GET",
    "base_url": "http://api.qichacha.com/ECIV4/Search",
    "content_type": "application/x-www-form-urlencoded",
    // 参数位置映射：'query' (URL参数) | 'body' (请求体) | 'path' (路径参数)
    "param_placement": "query" 
  },

  // 4. Auth Mapping: 动态鉴权逻辑
  // 解释：从运行时注入的 Payload.credentials 中取出 'QCC_KEY' 和 'QCC_SECRET'
  // 然后映射到 HTTP 请求的 Header 或 Query 中
  "auth_config": {
    "type": "api_key", // 支持 api_key | bearer | basic | oauth2
    "mapping": [
      {
        "source": "QCC_KEY",       // 对应 Payload 里的 Key 名称
        "target": "Token",         // HTTP Header 里的 Key 名称
        "location": "header"       // 放在 header 还是 query
      },
      {
        "source": "QCC_SECRET",    // 某些 API 需要签名或额外 ID
        "target": "Timespan",      // 假设企查查还需要时间戳(这里仅作示例)
        "location": "header"
      }
    ]
  }
}
```

### 三、 数据库设计 (RuoYi 侧)
在 RuoYi-Cloud 的 MySQL 中，我们需要一张表来管理这些插件。

**表名：**`**sys_ai_plugin**`

| **<font style="color:rgb(27, 28, 29);">字段名</font>** | **<font style="color:rgb(27, 28, 29);">类型</font>** | **<font style="color:rgb(27, 28, 29);">说明</font>** |
| --- | --- | --- |
| `<font style="color:rgb(68, 71, 70);">plugin_id</font>` | <font style="color:rgb(27, 28, 29);">BIGINT</font> | <font style="color:rgb(27, 28, 29);">主键</font> |
| `<font style="color:rgb(68, 71, 70);">name</font>` | <font style="color:rgb(27, 28, 29);">VARCHAR</font> | <font style="color:rgb(27, 28, 29);">英文唯一标识 (如 </font>`<font style="color:rgb(68, 71, 70);">search_company</font>`<br/><font style="color:rgb(27, 28, 29);">)</font> |
| `<font style="color:rgb(68, 71, 70);">title</font>` | <font style="color:rgb(27, 28, 29);">VARCHAR</font> | <font style="color:rgb(27, 28, 29);">中文名称 (如 </font>`<font style="color:rgb(68, 71, 70);">企查查企业搜索</font>`<br/><font style="color:rgb(27, 28, 29);">)</font> |
| `<font style="color:rgb(68, 71, 70);">description</font>` | <font style="color:rgb(27, 28, 29);">TEXT</font> | <font style="color:rgb(27, 28, 29);">给 LLM 看的提示词 (Prompt)</font> |
| `<font style="color:rgb(68, 71, 70);">icon_url</font>` | <font style="color:rgb(27, 28, 29);">VARCHAR</font> | <font style="color:rgb(27, 28, 29);">前端显示的图标</font> |
| `<font style="color:rgb(68, 71, 70);">parameter_schema</font>` | <font style="color:rgb(27, 28, 29);">JSON</font> | <font style="color:rgb(27, 28, 29);">对应协议中的 </font>`<font style="color:rgb(68, 71, 70);">parameters</font>`<br/><font style="color:rgb(27, 28, 29);"> 字段</font> |
| `<font style="color:rgb(68, 71, 70);">execution_config</font>` | <font style="color:rgb(27, 28, 29);">JSON</font> | <font style="color:rgb(27, 28, 29);">对应协议中的 </font>`<font style="color:rgb(68, 71, 70);">execution</font>`<br/><font style="color:rgb(27, 28, 29);"> 和 </font>`<font style="color:rgb(68, 71, 70);">auth_config</font>`<br/><font style="color:rgb(27, 28, 29);"> 字段</font> |
| `<font style="color:rgb(68, 71, 70);">status</font>` | <font style="color:rgb(27, 28, 29);">CHAR</font> | <font style="color:rgb(27, 28, 29);">启用/禁用</font> |
| `<font style="color:rgb(68, 71, 70);">required_credentials</font>` | <font style="color:rgb(27, 28, 29);">JSON</font> | <font style="color:rgb(27, 28, 29);">声明此插件依赖哪些 Key (如 </font>`<font style="color:rgb(68, 71, 70);">["QCC_KEY"]</font>`<br/><font style="color:rgb(27, 28, 29);">)，用于校验用户凭证</font> |




### 四、 运行时执行逻辑
#### 4.1 凭证注入与载荷组装 - [RuoYi 侧]  
当用户发起请求时，RuoYi 负责组装 `Runtime Config`：

1. **检索**：根据 Agent 绑定的插件，从 `sys_ai_plugin` 读取定义。
2. **鉴权检测**：检查插件的 `required_credentials`。
3. **解密**：从 `sys_user_credential` 表中取出对应的加密 Key，解密为明文。
4. **注入**：构建 Payload，包含插件定义和解密后的凭证字典（Credentials Dict）。

#### 4.2 跨服务传输
**动作发生地**：内网 HTTP 通道

1. **协议传输**：RuoYi 将 JSON Payload 通过 HTTP POST 发送至 Megumi Engine (Python) 的内部接口。
2. **环境初始化**：Python 接收请求，初始化 LangGraph 状态机，将 `runtime_config` 存入当前执行上下文（State）。

#### 4.3 模型感知与决策- [Python 侧]
**这是连接“静态配置”与“动态推理”的关键认知环节。**

1. **工具绑定 (Tool Binding)**：
    - **提取定义**：Python 引擎从 `runtime_config` 中读取 `plugins` 列表。
    - **格式转换**：提取每个插件的 `name`、`description` 和 `parameters` (JSON Schema) 字段。
    - **协议适配**：将其转换为 LLM 能够理解的标准工具描述格式（如 OpenAI `tools` 数组结构）。
    - _注：此时 _`_execution_`_ 和 _`_auth_config_`_ 字段被隐藏，LLM 仅能看到“工具是做什么的”以及“参数怎么填”。_
2. **推理请求 (Inference Request)**：
    - Python 引擎将 **对话历史 (Messages)** + **工具描述列表 (Tools)** + **用户最新问题** 组装成 Prompt，发送给 OneAPI/LLM。
3. **决策生成 (Decision Making)**：
    - **思考**：LLM 分析用户意图（例如：“查一下字节跳动”），匹配工具描述（发现 `search_company` 能查企业）。
    - **产出**：LLM **不返回文本**，而是返回一个结构化的 `ToolCall` 对象（包含 `name="search_company"` 和 `arguments={"keyword": "字节跳动"}`）。

#### 4.4 盲执行流程
Python 端的 `MCPPluginRunner` 执行步骤如下：

1. **解析调用意图**：LLM 返回 Function Call，包含 `name="search_company"` 和 `args={"keyword": "字节跳动"}`。
2. **加载配置**：从 Payload 的 `plugins` 列表中找到 `search_company` 的 `execution` 配置。
3. **鉴权填充**：
    - 读取 `auth_config`，发现需要 `source="QCC_KEY"`。
    - 从 Payload 的 `credentials` 字典中查找 `QCC_KEY` 的值（如 `sk-123...`）。
    - 根据 `target="Token"` 和 `location="header"`，将 `Token: sk-123...` 添加到 HTTP Headers 中。
4. **请求发送**：使用 `httpx` 或 `requests` 库，根据 `method` 和 `url` 发起真实网络请求。
5. **结果回填**：将 API 返回的 JSON 直接作为 Tool Output 反馈给 LLM。

