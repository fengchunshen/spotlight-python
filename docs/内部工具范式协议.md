### 一、核心设计理念

**原生工具 (Native Tool)** 指直接运行在 Python 内部、具有高计算密度或需调用本地资源的逻辑模块。

- 适用场景：深度搜索 (DeepSearch)、本地知识库检索 (RAG)、代码沙箱 (CodeSandbox)、复杂数据分析。
- 核心特征：
  - 代码优先：定义与逻辑均由 Python 代码控制。
  - 状态有感：可访问内存中的全局状态或上下文。
  - 高权限：直接运行在服务端环境（需严格代码审查）。

### 二、架构原则：代码驱动，镜像映射

为解决 “Java 定义与 Python 代码脱节” 的问题，本协议采用代码优先生成 Schema 策略：

- Python 侧：开发者在 Python 代码中通过 Pydantic 定义输入参数，这是唯一真理来源。
- RuoYi 侧：数据库 `sys_ai_plugin` 仅作为元数据镜像，存储 Python 生成的 JSON Schema，供 LLM 读取，但不负责定义修改。

### 三、数据库设计

复用 `sys_ai_plugin` 表，通过一个字段区分类型。

| 字段               | 外部插件 (External)          | 内部工具 (Native)                                  |
| ---               | ---                          | ---                                               |
| `type`            | `HTTP`                       | `NATIVE`                                          |
| `name`            | `search_qichacha`            | `deep_search`                                     |
| `parameter_schema`| JSON Schema                  | JSON Schema（必须与 Python 代码的参数对齐）        |
| `execution_config`| `{ "url": "...", "method": "GET" }` | `{ "class_name": "DeepSearchTool" }`        |

### 四、协议调整：知识库管理与推理“双轨”模式

- 分层原则：
  - 管理面（CRUD/入库/配置）走独立 REST 服务，不纳入内部工具范式，也不写入 `sys_ai_plugin`。路由内调用服务层，直接返回 JSON。
  - 推理面（查询/RAG/对话增强）继续用内部工具 + 工作流，保留 LangGraph/SSE 事件化能力，并在 `sys_ai_plugin` 注册。
- 路由形态：
  - `/v1/knowledge/*`：管理面专用路由（示例：create/delete/upsert/update_config/list/list_docs），一次性 JSON 响应；查询若需要流式可选 SSE，否则 JSON 返回。
  - `/v1/run_workflow`：推理面入口（如 `workflow_id=knowledge_rag`），触发内部工具调用与事件流。
- Pydantic 模型与 Schema：
  - 管理面：请求/响应使用 Pydantic 校验，**不**镜像到 `sys_ai_plugin`，仅服务内部使用；可用 Field alias 兼容 Java 字段。
  - 推理面：查询工具的参数模型由 Pydantic 定义，`model_json_schema()` 镜像入 `sys_ai_plugin`（`type=NATIVE`，`execution_config` 指向工具类）。
- 事件与返回：
  - 管理面：默认 JSON，一般不触发工具事件；如启用流式查询，可复用 `tool_thinking/tool_start/tool_result/message_chunk/done/error`，并使用 `sse/emitter.py.format_sse` 封装。
  - 推理面：保持 SSE 精细事件与 `trace_id` 透传。
- 安全与治理：
  - 管理面在路由/服务层做租户/ACL 校验与早返回，日志脱敏，不记录全文或密钥。
  - 推理面沿用现有日志与异常规范，`trace_id` 全链路透传。

